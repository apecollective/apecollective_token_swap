<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8" />
  <title>Trader Joe AVAX Token Swapper</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
</head>
<body class="bg-gray-900 text-white min-h-screen flex items-center justify-center p-6">

  <div class="w-full max-w-md bg-gray-800 p-6 rounded-lg shadow-lg">
    <h1 class="text-3xl font-bold mb-6 text-center">Trader Joe AVAX Swapper</h1>

    <button id="connectBtn" class="w-full bg-blue-600 hover:bg-blue-700 py-2 rounded mb-4">Connect Wallet</button>
    <p id="account" class="text-center text-sm mb-6"></p>

    <div>
      <label class="block mb-1">From Token</label>
      <div id="fromDropdown" class="bg-gray-700 rounded p-2 cursor-pointer relative mb-4">
        <span id="fromLabel" class="flex items-center gap-2">Select token</span>
        <div id="fromList" class="absolute top-full left-0 right-0 bg-gray-800 rounded mt-1 shadow-lg max-h-48 overflow-auto hidden z-10"></div>
      </div>
    </div>

    <div>
      <label class="block mb-1">To Token</label>
      <div id="toDropdown" class="bg-gray-700 rounded p-2 cursor-pointer relative mb-4">
        <span id="toLabel" class="flex items-center gap-2">Select token</span>
        <div id="toList" class="absolute top-full left-0 right-0 bg-gray-800 rounded mt-1 shadow-lg max-h-48 overflow-auto hidden z-10"></div>
      </div>
    </div>

    <label class="block mb-1">Amount</label>
    <input id="amountInput" type="number" min="0" step="any" placeholder="0.1" class="w-full p-2 mb-4 rounded bg-gray-700 border border-gray-600 text-white" />

    <p id="priceEstimate" class="text-gray-400 text-center mb-4"></p>

    <button id="swapBtn" class="w-full bg-green-600 hover:bg-green-700 py-2 rounded disabled:opacity-50" disabled>Swap Now</button>

    <p id="status" class="text-center mt-4"></p>
  </div>

  <script>
    // Trader Joe Router Address & WAVAX token address on Avalanche
    const ROUTER_ADDRESS = "0x60aE616a2155Ee3d9A68541Ba4544862310933d4";
    const WAVAX = "0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7";

    // ERC20 ABI (minimal)
    const ERC20_ABI = [
      "function balanceOf(address) view returns (uint256)",
      "function decimals() view returns (uint8)",
      "function approve(address spender, uint256 amount) returns (bool)"
    ];

    // Router ABI (only required functions)
    const ROUTER_ABI = [
      "function swapExactAVAXForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) payable returns (uint[] memory amounts)",
      "function swapExactTokensForAVAX(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) returns (uint[] memory amounts)",
      "function getAmountsOut(uint amountIn, address[] memory path) view returns (uint[] memory amounts)"
    ];

    // Tokens supported
    const TOKENS = {
      AVAX: {
        symbol: "AVAX",
        address: null,
        logo: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/avalanchec/info/logo.png",
      },
      "USDC.e": {
        symbol: "USDC.e",
        address: "0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E",
        logo: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/avalanchec/assets/0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E/logo.png",
      },
      "DAI.e": {
        symbol: "DAI.e",
        address: "0xd586E7F844cEa2F87f50152665BCbc2C279D8d70",
        logo: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/avalanchec/assets/0xd586E7F844cEa2F87f50152665BCbc2C279D8d70/logo.png",
      },
    };

    // Globals
    let provider, signer, router;
    let userAddress = null;
    let fromToken = "AVAX";
    let toToken = "USDC.e";

    // UI elements
    const connectBtn = document.getElementById("connectBtn");
    const accountP = document.getElementById("account");
    const fromDropdown = document.getElementById("fromDropdown");
    const toDropdown = document.getElementById("toDropdown");
    const fromList = document.getElementById("fromList");
    const toList = document.getElementById("toList");
    const fromLabel = document.getElementById("fromLabel");
    const toLabel = document.getElementById("toLabel");
    const amountInput = document.getElementById("amountInput");
    const priceEstimate = document.getElementById("priceEstimate");
    const swapBtn = document.getElementById("swapBtn");
    const statusP = document.getElementById("status");

    // Connect wallet and load balances
    async function connectWallet() {
      if (!window.ethereum) {
        alert("Please install MetaMask!");
        return;
      }

      provider = new ethers.providers.Web3Provider(window.ethereum);
      await provider.send("eth_requestAccounts", []);
      signer = provider.getSigner();
      userAddress = await signer.getAddress();

      router = new ethers.Contract(ROUTER_ADDRESS, ROUTER_ABI, signer);

      accountP.textContent = `Connected: ${userAddress}`;

      connectBtn.disabled = true;
      await updateBalances();
      enableSwapIfReady();
    }

    // Update token balances and populate dropdowns
    async function updateBalances() {
      fromList.innerHTML = "";
      toList.innerHTML = "";

      for (const key of Object.keys(TOKENS)) {
        const token = TOKENS[key];
        let balance = "0.0000";

        try {
          if (!token.address) {
            // AVAX balance
            const rawBal = await provider.getBalance(userAddress);
            balance = parseFloat(ethers.utils.formatEther(rawBal)).toFixed(4);
          } else {
            // ERC20 token balance
            const contract = new ethers.Contract(token.address, ERC20_ABI, provider);
            const rawBal = await contract.balanceOf(userAddress);
            const decimals = await contract.decimals();
            balance = parseFloat(ethers.utils.formatUnits(rawBal, decimals)).toFixed(4);
          }
        } catch (err) {
          balance = "0.0000";
        }

        // Create dropdown item
        const itemFrom = createDropdownItem(token, balance, key, true);
        const itemTo = createDropdownItem(token, balance, key, false);

        fromList.appendChild(itemFrom);
        toList.appendChild(itemTo);
      }

      // Set defaults
      setFromToken(fromToken);
      setToToken(toToken);
    }

    function createDropdownItem(token, balance, key, isFromDropdown) {
      const div = document.createElement("div");
      div.className = "flex items-center gap-2 px-4 py-2 hover:bg-gray-600 cursor-pointer";
      div.innerHTML = `<img src="${token.logo}" alt="${token.symbol}" class="w-5 h-5 rounded-full" referrerpolicy="no-referrer" onerror="this.src='https://via.placeholder.com/20'"/> ${token.symbol} (${balance})`;
      div.onclick = () => {
        if (isFromDropdown) setFromToken(key);
        else setToToken(key);
        hideDropdowns();
        estimatePrice();
      };
      return div;
    }

    function setFromToken(key) {
      fromToken = key;
      const token = TOKENS[key];
      fromLabel.innerHTML = `<img src="${token.logo}" alt="${token.symbol}" class="w-5 h-5 rounded-full" referrerpolicy="no-referrer" /> ${token.symbol}`;
      enableSwapIfReady();
    }

    function setToToken(key) {
      toToken = key;
      const token = TOKENS[key];
      toLabel.innerHTML = `<img src="${token.logo}" alt="${token.symbol}" class="w-5 h-5 rounded-full" referrerpolicy="no-referrer" /> ${token.symbol}`;
      enableSwapIfReady();
    }

    function hideDropdowns() {
      fromList.classList.add("hidden");
      toList.classList.add("hidden");
    }

    fromDropdown.onclick = () => {
      toList.classList.add("hidden");
      fromList.classList.toggle("hidden");
    };

    toDropdown.onclick = () => {
      fromList.classList.add("hidden");
      toList.classList.toggle("hidden");
    };

    amountInput.oninput = estimatePrice;

    // Enable swap button only if input is valid & tokens are selected & connected
    function enableSwapIfReady() {
      const amount = parseFloat(amountInput.value);
      swapBtn.disabled = !userAddress || !fromToken || !toToken || fromToken === toToken || !amount || amount <= 0;
    }

    amountInput.addEventListener("input", () => {
      enableSwapIfReady();
      estimatePrice();
    });

    swapBtn.onclick = async () => {
      if (!userAddress) {
        alert("Connect wallet first");
        return;
      }

      if (fromToken === toToken) {
        alert("From and To tokens must be different");
        return;
      }

      const amount = amountInput.value;
      if (!amount || isNaN(amount) || amount <= 0) {
        alert("Enter a valid amount");
        return;
      }

      try {
        swapBtn.disabled = true;
        statusP.textContent = "Swapping... Please confirm transaction in wallet.";

        const amountIn = ethers.utils.parseEther(amount);
        const deadline = Math.floor(Date.now() / 1000) + 60 * 20; // 20 minutes

        let tx;

        if (fromToken === "AVAX") {
          // Swap AVAX to Token
          const path = [WAVAX, TOKENS[toToken].address];
          tx = await router.swapExactAVAXForTokens(
            0, // amountOutMin: 0 = no slippage protection, increase for production
            path,
            userAddress,
            deadline,
            { value: amountIn }
          );
        } else if (toToken === "AVAX") {
          // Swap Token to AVAX
          const tokenContract = new ethers.Contract(TOKENS[fromToken].address, ERC20_ABI, signer);
          // Approve router to spend tokens
          const approvalTx = await tokenContract.approve(ROUTER_ADDRESS, amountIn);
          statusP.textContent = "Approving tokens...";
          await approvalTx.wait();

          const path = [TOKENS[fromToken].address, WAVAX];
          tx = await router.swapExactTokensForAVAX(
            amountIn,
            0, // amountOutMin
            path,
            userAddress,
            deadline
          );
        } else {
          alert("Currently only AVAX <> Token swaps are supported.");
          swapBtn.disabled = false;
          return;
        }

        statusP.textContent = `Transaction sent: ${tx.hash}`;
        await tx.wait();
        statusP.textContent = "✅ Swap completed successfully!";
        await updateBalances();
        amountInput.value = "";
        priceEstimate.textContent = "";
      } catch (error) {
        statusP.textContent = `❌ Swap failed: ${error.message || error}`;
      }
      swapBtn.disabled = false;
    };

    // Estimate price function
    async function estimatePrice() {
      priceEstimate.textContent = "";
      if (!userAddress || !fromToken || !toToken) return;
      const amount = amountInput.value;
      if (!amount || isNaN(amount) || amount <= 0) return;

      try {
        const amountIn = ethers.utils.parseEther(amount);
        let path;
        if (fromToken === "AVAX") {
          path = [WAVAX, TOKENS[toToken].address];
        } else if (toToken === "AVAX") {
          path = [TOKENS[fromToken].address, WAVAX];
        } else {
          priceEstimate.textContent = "Price estimate only for AVAX <> Token swaps.";
          return;
        }
        const amountsOut = await router.getAmountsOut(amountIn, path);
        const outAmount = ethers.utils.formatEther(amountsOut[1]);
        priceEstimate.textContent = `Estimated output: ${parseFloat(outAmount).toFixed(6)} ${toToken}`;
      } catch (err) {
        priceEstimate.textContent = "Could not estimate price.";
      }
    }

    connectBtn.onclick = connectWallet;

  </script>

</body>
</html>
